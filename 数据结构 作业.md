## 线性结构
1.3 
头节点作用：便于对空链表进行操作；在首项插入时与对其他节点的操作保持一致；
头指针：用于存放线性链表中的第一个节点的存储地址，是单链表的标识；
头节点：线性链表的第一个元素节点前面的一个附加节点；
首元节点：线性链表的第一个存储信息节点，地址储存在头指针中。
1.4
顺序表存储空间连续，存储密度高，但是存储容量固定；链表存储密度低，存储容量可变，
故在对线性表的存储规模难以估计时，选用链表；
顺序表中访问元素的时间复杂度为O(1)，链表为O(n)。若经常按序号读取元素，选用顺序表；
顺序表插入删除操作较链表来说更加复杂，若频繁进行插入删除操作，选用链表。
1.5
采用链表。
顺序表在插入和删除时，平均要移动表中的一半元素，当数据量较大时，操作复杂且耗时，而链表的插入删除操作主要是比较，相比而言更加便捷。
1.6
采用尾指针。
设有尾指针的单循环链表可以方便地进行尾部插入元素，只需修改尾指针和新节点指针的指向即可，在头部插入时，由于该链表为单循环链表，所以可以通过尾指针快速找到链表的第一个元素，方便进行插入操作。
1.7
使用两个栈来实现，一个入队栈，一个出队栈，入队时将元素压入入队栈中，出队时，先将入队栈中的元素弹出并压入出队栈之中，全部压入出队栈之后再弹出。
1.8
（1）4000
（2）8000
（3）6860

2
2.1
设置首尾两个索引，从两边向中间靠拢，就索引位置数组元素和与目标和的大小来增加i或者减少j；
```c
//nums[]数组为已经升序排列过的数组，大小为N
//answers[]数组大小为2，用于存放结果
//target为目标和
//若未找到这两个数，则返回-1，否则返回0
int twoSum(int[] nums, int target, int answers[]) {
	int i = 0;
	int j = N -1;
	while(i < j) {
	    int num = nums[i] + nums[j];
		if (num == target) {
			answers[0] = nums[i];
			answers[1] = nums[j];
			return 0;
		} else if (num > taget) {
			j -= 1;
		} else if (num < target) {
			i += 1;
		}
	}
	return -1
}
```
最坏的情况为i自增运算次数和j自减运算次数和为n，故时间复杂度为O(n);
空间复杂度为O(1).

2.2
按链表顺序入栈后，越在前面的元素越接近栈底，从而出栈时顺序和原链表顺序相反；
```c
void reverse(LinkList* H, Stack S) {
    //按单链表顺序将其中元素入栈
	for (int i = 0; i < ListLength(H); i ++) {
		push(&S, GetElem(H, i));
	}
	LinkList tempL;
	InitList(&temrL);
	//出栈并将元素加入新链表，即获得反向的链表
	for (int i = 0; i < ListLength(H); i ++) {
		InsertList(&tempL, pop(&S), i);
	}
	H = &temL;
}
```
时间复杂度T(n) = 2n，故为O(n)；
空间复杂度为O(1)

2.3
顺序表中使用首尾两个索引，自两边向中间靠拢，异号就进行交换；
单向链表中设置两个暂时的头节点，遍历单向链表，将负数插入一个头节点之后，将非负数插入另一个之后，最后将一个的尾节点指向另一个的首节点；
```c
//顺序表实现
void SortSlist(SLIST* A) {
	int i = 0;
	int j = maxlength - 1;
	while (i < j) {
		if (A.data[i] < 0) {
			i += 1;
		}
		if (A.data[j] > 0) {
			j += 1;
		}
		if (A.data[i] > 0 && A.data[j] < 0) {
			int temp = A.data[i];
			A.data[i] = A.data[j];
			A.data[j] = temp;
		}
	}
}

//单项链表实现
void SortLlist(LLIST* H) {
	LLIST A;
	LLIST B;
	for (LLIST* p = H; p->next != null; p = p->next) {
		if (p->data < 0) {
			A.next = p;
		} else {
			B.next = p;
		}
	}
	LLIST* last = H->next;
	while(last->next != null) {
		last = last->next;	
	}
	last->next = B.next;
	H = &A;
}
```
顺序表实现中最坏的情况为i自增运算次数和j自减运算次数和为n，故时间复杂度为O(n);
单项链表实现中，T(n) = 2n，故时间复杂度为O(n);

2.4
先计算出单链表的长度，再将倒数转化为正数，然后从单链表开头开始遍历即可。
```c
int search(LinkList L, int k) {
	int length = 0;
	for (LinkList* p = &L; p->next != null; p = p-> next) {
		length += 1;
	}
	int count = 0; 
	int n = length + 1 - k;
	//若k越界，则返回0
	if (n < 0) {
		return 0;
	}
	for (LinkList* p = &L; p->next != null; p = p-> next) {
		if (count == n) {
			printf("%d", p->data);
			return 1;
		}
		count += 1;
	}
}
```
T(n) = 2n，故时间复杂度为O(n)，空间复杂度为O(1);

2.5
使用一个数组来记录A中每个元素是否出现，若第一次出现，则将对应值置为1，若再次出现，则返回结果。
```c
//存在相同元素返回1，否则返回0
int IsDuplicate(int A[m][n], int m, int n) {
	int map[100000] = {0};
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			int key = A[i][j];
			if (map[key] == 1) {
				return 1;
			}else if (map[key] == 0) {
				map[key] = 1;
			} 
		}
	}
	return 0;
}
```
只需遍历一次该二维数组，故时间复杂度为O(m*\n)，空间复杂度为O(1).

## 树型结构
1.1
(2) 
先序：efgicbadjh
中序：igfecbjdah
后序：igfbcejdha
(3)
双亲为空，左孩子为空，右孩子为b
(4)

1.2
选择二叉树T结点的前序和后序序列来判断结点n1是否是结点n2的祖先
1.  遍历T的前序序列，查找结点n1和结点n2的位置。
2.  遍历T的后序序列，查找结点n1和结点n2的位置。
3.  如果n1在n2之前出现在T的前序序列中，并且n1在n2之后出现在T的后序序列中，则n1是n2的祖先。否则，n1不是n2的祖先。

1.3
任意二叉树中，有n0 = n2 + 1,
而n1 = 1, 故有n0 = n2 + n1, 命题得证.

1.4
(1)
0.19: 00
0.21: 01
0.32: 10
0.07: 1100
0.10: 1101
0.06: 1110
0.02: 11110
0.03: 11111
(2)
0.19: 000
0.21: 001
0.32: 010
0.07: 011
0.10: 100
0.06: 101
0.02: 110
0.03: 111
(3)
第一种：压缩率高，编码长度差异较大，降低了通信效率；
第二种：压缩率低，编码长度固定，编码解码速度较快。

2.1
```C
//找出指定索引的深度
int FindDepth(int *a, int i) {
	int depth = 0;
	while (i >= 1) {
		depth += 1;
		i = i / 2;
	}
	return depth;
}
//返回最近的共同祖先的数组下标
int FindRoot(int* a, int i, int j) {
	int iDepth = FindDepth(i);
	int jDepth = findDepth(j);
	while (iDepth > jDepth) {
		i = i / 2;
		iDepth -= 1;
	}
	while (iDepth < jDepth) {
		j = j / 2;
		jDepth -= 1;
	}
	while (i != j) {
		i = i / 2;
		j = j / 2;
	}
	return i;
}
```
时间复杂度为O(logN),  空间复杂度为O(1).

2.2
```C
//由根向下递归查找，返回true就打印节点
bool find(BTree* p, int x) {
	if (p == NULL) {
		return false;
	} 
	if (p->val == x) {
		return true;
	}
	bool flag;
	//先查找左子树
	flag = find(p->left, x);
	if (flag) {
		printf("%d", p->val);
		return true;
	}
	//再查找右子树
	flag = find(p->right, x) 
	if (flag) {
		printf("%d", p->val);
		return true;
	}
}
```
时间复杂度O(N), 空间复杂度为O(1).


2.3
```C
//创建树节点
BTree* createTreeNode(int val, BTree* left, BTree* right) {  
	BTree* curr = (BTree*) (malloc(sizeof(BTree)));  
	curr->val = val;  
	curr->left = left;  
	curr->right = right;  
	return curr;  
}

//使用队列来构建树，空节点值为-1，返回树根节点
BTree* createTreeWithLevelOrder(ST st) {  
	QueuePtr qPtr = InitQueue();  
	BTree* root = NULL;  
	int i = 0;  
	if (st.data[i] == -1) {  
		return root;  
	}  
	root = createTreeNode(st.data[i], NULL, NULL);  
	EnQueue(qPtr, root);  
	while (!QueueEmpty(qPtr) && i < st.last) {  
		TreeNodePtr T = DeQueue(qPtr);  
		i++;  
		int leftData;  
		if (i >= st.last) {  
			leftData = -1;  
		} else {  
			leftData = data[i];  
		}  
		T->left = createTreeNode(leftData, NULL, NULL);  
		EnQueue(qPtr, T->left);  
		i++;  
		int rightData;  
		if (i >= st.last) {  
			rightData = -1;  
		} else {  
			rightData = data[i];  
		}  
		T->right = createTreeNode(rightData, NULL, NULL);  
		EnQueue(qPtr, T->right);  
	}  
	return root;  
}
```
时间复杂度 O(N), 空间复杂度O(1).

2.4

```C
//中序遍历的过程前后打印括号即可
void visit(BTree* root) {
	printf("(");
	visit(root->left);
	printf("%s", root->data);
	visit(root->right);
	printf(")");
}
```
时间复杂度O(N), 空间复杂度O(1).


2.5
```C
//返回数组中最大值的索引
int Max(int* a, int N) {
	int t = 0;
	int max = a[t];
	for (int i = 1; i < N; i++) {
		if (a[i] > max) {
			t = i;
		}
	}
	return t;
}

BTree* CreatMaxBTree(int* a, int N) {
	int index = Max(a, N);
	//复制最大值左右的两个数组的副本
	int left[index];
	int right[N - index - 1];
	for (int i = 0; i < index; i++) {
		left[i] = a[i];
	}
	for (int i = 0; i < N - index - 1; i++) {
		right[i] = a[N - index - 1];
	}
	BTree* root = (BTree*)malloc(szieof(Btree));
	root->val = a[index];
	//递归调用构建子树
	root->left = CreatMaxBTree(left, index);
	root->right = CreatMaxBTree(right, N - index - 1);
}
```
最坏情况：时间复杂度O(N * N), 空间复杂度O(NlogN);
最好情况：时间复杂度为O(N), 空间复杂度为O(N).